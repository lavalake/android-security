http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html
volatile:
  volatile guarantee the read and write will work direclty on the main memory not local cache or registers. On multiple CPU,
  thread can read the updated value from main memory. So if there is only one writer and multiple reader, you can use volatile.
  
  The race conditions occur when multiple threads perform a read-update-write sequence of operations on a shared variable. 
  If you only have one thread perform a read-update-write sequence of operations, and all other threads only perform a read 
  operation, you have no race conditions.
  
  Why is it Called Optimistic Locking?

The code shown in the previous section is called optimistic locking. Optimistic locking is different from traditional locking, 
sometimes also called pessimistic locking. Traditional locking blocks the access to the shared memory with a synchronized block
or a lock of some kind. A synchronized block or lock may result in threads being suspended.

Optimistic locking tends to work best with low to medium contention on the shared memory. If the content is very high on the 
shared memory, threads will waste a lot of CPU cycles copying and modifying the shared memory only to fail writing the changes
back to the shared memory. But, if you have a lot of content on shared memory, you should anyways consider redesigning your 
code to lower the contention.

