https://blog.csdn.net/q_l_s/article/details/70255115
对于使用synchronousQueue的线程池，在第一次execute任务的时候会在1处返回false，因为线程池中还没有线程，所以没有消费者在等待，所以就会直接创建线程进行执行任务
在上篇线程池的分析中我们提到：创建的线程在执行完毕任务后会去循环的getTask，在getTask的过程中会调用take去获取任务。所以当我们再次调用execute提交任务的时候1就会返回成功（前提是先前创建的线程已经执行完毕，正在执行gettask方法进行等待），因为这个时候已经有一个线程在等待task了，所以offer直接返回成功！
这就达到了cachedThreadPool线程复用的目的，也就是说：在提交任务的时候，如果所有工作线程都处于忙碌的状态就会新建线程来执行，如果有工作线程处于空闲状态则把任务交给空闲线程来执行！而这其中的黑科技就是通过synchronousQueue来进行的。

作者：recklessMo
链接：https://juejin.im/post/59f2e50151882546b15bc20d
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
