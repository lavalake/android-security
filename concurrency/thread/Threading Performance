https://developer.android.com/topic/performance/threads.html
Persisting threads
Threads persist past the lifetime of the activities that spawn them. Threads continue to execute, uninterrupted, 
regardless of the creation or destruction of activities. In some cases, this persistence is desirable.

The main thread has a very simple design: Its only job is to take and execute blocks of work from a thread-safe 
work queue until its app is terminated

 If the main thread cannot finish executing blocks of work within 16ms, the user may observe hitching, lagging, 
 or a lack of UI responsiveness to input. If the main thread blocks for approximately five seconds, the system displays
 the Application Not Responding (ANR) dialog, allowing the user to close the app directly.
 
 By design, Android View objects are not thread-safe. An app is expected to create, use, and destroy UI objects, 
 all on the main thread. If you try to modify or even reference a UI object in a thread other than the main thread, 
 the result can be exceptions, silent failures, crashes, and other undefined misbehavior.

Explicit references
In another example, View objects contain references to the activity that owns them. If that activity is destroyed, 
but there remains a threaded block of work that references it—directly or indirectly—the garbage collector will not 
collect the activity until that block of work finishes executing.

This scenario can cause a problem in situations where threaded work may be in flight while some activity lifecycle event, 
such as a screen rotation, occurs. The system wouldn’t be able to perform garbage collection until the in-flight work completes.
As a result, there may be two Activity objects in memory until garbage collection can take place.

With scenarios like these, we suggest that your app not include explicit references to UI objects in threaded work tasks. 
Avoiding such references helps you avoid these types of memory leaks, while also steering clear of threading contention.

In all cases, your app should only update UI objects on the main thread

Implicit references

A common code-design flaw with threaded objects can be seen in the snippet of code below:
The flaw in this snippet is that the code declares the threading object MyAsyncTask as a non-static inner class of some 
activity (or an inner class in Kotlin). This declaration creates an implicit reference to the enclosing Activity instance. 
As a result, the object contains a reference to the activity until the threaded work completes, causing a delay in the 
destruction of the referenced activity. This delay, in turn, puts more pressure on memory.

Generally, threads in the foreground group get about 95% of the total execution time from the device, while the background group gets roughly 5%.

The AsyncTask class

The AsyncTask class is a simple, useful primitive for apps that need to quickly move work from the main thread onto worker 
threads

When using AsyncTask, there are a few important performance aspects to keep in mind. First, by default, an app pushes all of 
the AsyncTask objects it creates into a single thread
or this reason, we suggest that you only use AsyncTask to handle work items shorter than 5ms in duration.
